// src/libs/config/parser.ts
var buildDefaults = {
  srcPath: "./src",
  outputPath: "./public",
  cleanUrls: true
};
var parseOptions = (options) => {
  const { srcPath, outputPath, cleanUrls } = Object.assign(
    {},
    buildDefaults,
    options.build
  );
  const site = options.site || {};
  return { srcPath, outputPath, cleanUrls, site };
};

// src/libs/logger/logger.ts
import pc from "picocolors";
var log = {
  info(message) {
    console.log(`${pc.gray("[nanogen]")} ${message}`);
  },
  success(message) {
    console.log(`${pc.gray("[nanogen]")} ${pc.green(message)}`);
  },
  error(message) {
    console.log(`${pc.gray("[nanogen]")} ${pc.red(message)}`);
  }
};

// src/modules/build/build.ts
import ejs from "ejs";
import frontMatter from "front-matter";
import fse from "fs-extra";
import { glob } from "glob";
import { marked } from "marked";
import path from "node:path";
import { hrtime } from "node:process";
var WS_CLIENT_SCRIPT = `
<script>
  (function() {
    const ws = new WebSocket(\`ws://\${location.host}\`);
    ws.onmessage = () => location.reload();
  })();
</script>
</body>`;
var build = (options = {}, mode = process.env.NODE_ENV || "production") => {
  log.info("Building site...");
  const startTime = hrtime.bigint();
  const { srcPath, outputPath, cleanUrls, site } = parseOptions(options);
  fse.emptyDirSync(outputPath);
  if (fse.existsSync(`${srcPath}/assets`)) {
    fse.copySync(`${srcPath}/assets`, outputPath);
  }
  const files = glob.sync("**/*.@(md|ejs|html)", { cwd: `${srcPath}/pages` });
  files.forEach(
    (file) => _buildPage(file, { srcPath, outputPath, cleanUrls, site }, mode)
  );
  const timeDiff = process.hrtime.bigint() - startTime;
  const duration = Number(timeDiff) / 1e6;
  log.success(`Site built successfully in ${duration} ms`);
};
var _loadLayout = (layout, { srcPath }) => {
  const file = `${srcPath}/layouts/${layout}.ejs`;
  const data = fse.readFileSync(file, "utf-8");
  return { file, data };
};
var _buildPage = (file, { srcPath, outputPath, cleanUrls, site }, mode) => {
  const fileData = path.parse(file);
  let destPath = path.join(outputPath, fileData.dir);
  if (cleanUrls && fileData.name !== "index") {
    destPath = path.join(destPath, fileData.name);
  }
  fse.mkdirsSync(destPath);
  const data = fse.readFileSync(`${srcPath}/pages/${file}`, "utf-8");
  const pageData = frontMatter(data);
  const templateConfig = {
    site,
    page: pageData.attributes
  };
  let pageContent;
  const pageSlug = file.split(path.sep).join("-");
  switch (fileData.ext) {
    case ".md":
      pageContent = marked.parse(pageData.body, { async: false });
      break;
    case ".ejs":
      pageContent = ejs.render(pageData.body, templateConfig, {
        filename: `${srcPath}/page-${pageSlug}`
      });
      break;
    default:
      pageContent = pageData.body;
  }
  const layoutName = pageData.attributes.layout || "default";
  const layout = _loadLayout(layoutName, {
    srcPath
  });
  let completePage = ejs.render(
    layout.data,
    Object.assign({}, templateConfig, {
      body: pageContent,
      filename: `${srcPath}/layout-${layoutName}`
    })
  );
  if (mode !== "production") {
    completePage = completePage.includes("</body>") ? completePage.replace("</body>", WS_CLIENT_SCRIPT) : completePage + WS_CLIENT_SCRIPT;
  }
  if (cleanUrls) {
    fse.writeFileSync(`${destPath}/index.html`, completePage);
  } else {
    fse.writeFileSync(`${destPath}/${fileData.name}.html`, completePage);
  }
};

// src/modules/init/init.ts
import fse2 from "fs-extra";
import { createSpinner } from "nanospinner";
import cp from "node:child_process";
import path2 from "node:path";
import { fileURLToPath } from "node:url";
import util from "node:util";
import pc2 from "picocolors";
var exec = util.promisify(cp.exec);
var __filename = fileURLToPath(import.meta.url);
var __dirname = path2.dirname(__filename);
var init = async (templateDir = "../template") => {
  log.info("Initializing a new Nanogen site ...");
  fse2.copySync(path2.resolve(__dirname, templateDir), ".");
  const spinner = createSpinner("Installing dependencies...").start();
  await exec("npm i --loglevel error");
  spinner.success();
  log.success(`Site initialized successfully!`);
  log.info(
    `Now you can run:
  ${pc2.cyan("npm start")}      to start your new site, or
  ${pc2.cyan("npm run build")}  to build it into the 'public' folder.`
  );
};

// src/libs/server/server.ts
import http from "node:http";
import sirv from "sirv";
import { WebSocketServer } from "ws";
var server = {
  serve({ path: path3, port = 3e3 }) {
    const staticHandler = sirv(path3, {
      dev: true,
      etag: true,
      single: true
    });
    const server2 = http.createServer((req, res) => {
      staticHandler(req, res);
    });
    const wss = new WebSocketServer({ server: server2 });
    wss.on("connection", (ws) => {
      ws.on("error", console.error);
    });
    server2.listen(port, () => {
      console.log(`Server running at http://localhost:${port}`);
    });
    return {
      reload: () => {
        wss.clients.forEach((client) => {
          client.send("reload");
        });
      }
    };
  }
};

// src/modules/serve/serve.ts
import chokidar from "chokidar";
import debounce from "lodash.debounce";
var serve = (options, flags) => {
  log.info(`Starting local server at http://localhost:${flags.port}`);
  const { srcPath, outputPath } = parseOptions(options);
  build(options, "development");
  const { reload } = server.serve({
    path: outputPath,
    port: Number(flags.port)
  });
  chokidar.watch(srcPath, { ignoreInitial: true }).on(
    "all",
    debounce(() => {
      build(options, "development");
      reload();
      log.info("Waiting for changes...");
    }, 500)
  );
};
export {
  build,
  init,
  serve
};
